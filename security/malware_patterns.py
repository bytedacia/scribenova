"""
Pipeline Protezione Codice Malevolo: pattern webshell, backdoor, reverse shell, offuscamento.
"""
import os
import re
from typing import Dict, List, Tuple

# Webshell / backdoor comuni
WEBSHELL_PATTERNS = [
    (re.compile(r"eval\s*\(\s*(base64|request|POST|GET)\s*\.", re.I), "webshell_eval_request"),
    (re.compile(r"assert\s*\(.*\)\s*;", re.I), "webshell_assert"),
    (re.compile(r"passthru\s*\(|shell_exec\s*\(|system\s*\(.*\$_(GET|POST)", re.I), "webshell_php"),
    (re.compile(r"<\?php\s*@?\s*(eval|assert|base64_decode)\s*\(", re.I), "webshell_php_eval"),
    (re.compile(r"Runtime\.getRuntime\(\)\.exec\s*\(|ProcessBuilder\s*\(", re.I), "webshell_java"),
]

# Reverse shell e connessioni sospette
REVERSE_SHELL_PATTERNS = [
    (re.compile(r"socket\.socket\s*\(.*AF_INET.*SOCK_STREAM", re.I), "raw_socket"),
    (re.compile(r"subprocess\.(call|run|Popen|check_output)\s*\([^)]*shell\s*=\s*True", re.I), "shell_true"),
    (re.compile(r"os\.system\s*\(|os\.popen\s*\(|eval\s*\(|exec\s*\(", re.I), "dangerous_exec"),
    (re.compile(r"__import__\s*\(\s*['\"]os['\"]\s*\)\.system\s*\(|__import__\s*\(\s*['\"]subprocess['\"]\s*\)", re.I), "obfuscated_import"),
    (re.compile(r"bash\s+-i\s+|/bin/bash\s+-i|nc\s+-e\s+/bin|ncat.*--sh-exec", re.I), "reverse_shell_cmd"),
    (re.compile(r"pty\.spawn\s*\(|popen2\s*\(|commands\.getoutput", re.I), "legacy_shell"),
]

# Offuscamento sospetto
OBFUSCATION_PATTERNS = [
    (re.compile(r"base64\.b64decode\s*\([^)]+\)\s*\)?\s*\)?\s*\)?\s*\)"), "base64_decode_chain"),
    (re.compile(r"chr\s*\(\s*\d+\s*\)\s*\+\s*chr\s*\(\s*\d+\s*\)", re.I), "chr_concat"),
    (re.compile(r"getattr\s*\(\s*\w+\s*,\s*['\"][^'\"]+['\"]\s*\)\s*\(\s*\)", re.I), "getattr_dynamic"),
    (re.compile(r"compile\s*\([^)]+\)\s*\)\s*\)", re.I), "compile_obfuscated"),
    (re.compile(r"decode\s*\(\s*['\"]unicode_escape['\"]\s*\)|encode\s*\(\s*['\"]rot13['\"]\s*\)", re.I), "encoding_obfuscation"),
    (re.compile(r"\\x[0-9a-fA-F]{2}\s*\\x[0-9a-fA-F]{2}\s*\\x", re.I), "hex_escape_chain"),
]

# Percorsi sensibili (file I/O)
SENSITIVE_PATHS = [
    re.compile(r"['\"]/etc/", re.I),
    re.compile(r"['\"]/etc/shadow|passwd", re.I),
    re.compile(r"\.ssh/|id_rsa|authorized_keys", re.I),
    re.compile(r"['\"]/root/", re.I),
    re.compile(r"open\s*\([^)]*['\"]/proc/", re.I),
]

# Cryptomining / botnet indicatori
CRYPTO_PATTERNS = [
    (re.compile(r"mining|miner|hashrate|stratum\+tcp|pool\.", re.I), "crypto_mining"),
    (re.compile(r"bot\.run|telegram\.send|discord\.webhook", re.I), "bot_telemetry"),
]

# Data exfiltration: invio dati sensibili verso URL esterni
EXFILTRATION_PATTERNS = [
    (re.compile(r"requests\.(post|put)\s*\(\s*['\"]https?://[^'\"]+['\"]", re.I), "exfil_requests_post"),
    (re.compile(r"requests\.(post|put).*\.(json|data)\s*=.*(password|secret|sensitive)", re.I), "exfil_sensitive_post"),
]

# Distruzione progetto / sabotaggio sicurezza: rimozione massiva, target security, hook, file critici
DESTRUCTION_PATTERNS = [
    (re.compile(r"shutil\.rmtree\s*\("), "destruction_rmtree"),
    (re.compile(r"os\.remove\s*\(|os\.unlink\s*\("), "destruction_remove"),
    (re.compile(r"rmtree\s*\([^)\]]*security", re.I), "sabotage_rmtree_security"),
    (re.compile(r"(?:remove|rmtree)\s*\([^)\]]*hooks", re.I), "sabotage_hooks"),
    (re.compile(r"(?:remove|rmtree)\s*\([^)\]]*security", re.I), "sabotage_security"),
    (re.compile(r"subprocess\.(run|call|Popen|check_output)\s*\([^)]*rm\s+-rf", re.I), "destruction_rm_rf"),
    (re.compile(r"open\s*\([^)]*['\"].*app\.py['\"][^)]*['\"]w['\"]"), "sabotage_overwrite_critical"),
    (re.compile(r"\.git/hooks|git/hooks"), "sabotage_git_hooks"),
    # Evasione: subprocess con lista (no shell=True) che invoca rm/rd
    (re.compile(r"subprocess\.(run|call|Popen|check_output)\s*\(\s*\[[^\]]*['\"]rm['\"]"), "destruction_subprocess_rm_list"),
    (re.compile(r"subprocess\.(run|call|Popen|check_output)\s*\(\s*\[[^\]]*['\"]rd['\"]"), "destruction_subprocess_rd_list"),
    # Evasione: pathlib su directory sensibili (security, .git/hooks)
    (re.compile(r"Path\s*\([^)]*['\"]security['\"]\s*\)\.(rmdir|rglob|unlink)"), "sabotage_pathlib_security"),
    (re.compile(r"\.rglob\s*\([^)]*\)\s*\n?\s*.*\.unlink\s*\("), "destruction_pathlib_rglob_unlink"),
]


def scan_content(content: str, filepath: str = "") -> List[Tuple[str, str, int]]:
    """
    Scansiona contenuto. Restituisce lista (pattern_name, line_snippet, line_num).
    """
    findings = []
    lines = content.splitlines()
    for i, line in enumerate(lines, 1):
        for pat, name in WEBSHELL_PATTERNS + REVERSE_SHELL_PATTERNS + OBFUSCATION_PATTERNS + CRYPTO_PATTERNS + EXFILTRATION_PATTERNS + DESTRUCTION_PATTERNS:
            if pat.search(line):
                snippet = line.strip()[:80] + ("..." if len(line) > 80 else "")
                findings.append((name, snippet, i))
                break
        for pat in SENSITIVE_PATHS:
            if pat.search(line):
                findings.append(("sensitive_path", line.strip()[:80], i))
                break
    return findings


def scan_file(filepath: str) -> List[Tuple[str, str, int]]:
    """Scansiona singolo file."""
    if not os.path.isfile(filepath):
        return []
    try:
        with open(filepath, "r", encoding="utf-8", errors="ignore") as f:
            content = f.read()
    except Exception:
        return []
    return scan_content(content, filepath)


def scan_directory(root: str, extensions: tuple = (".py", ".js", ".ts", ".php", ".sh", ".bat", ".ps1")) -> Dict[str, List[Tuple[str, str, int]]]:
    """Scansiona directory; restituisce {rel_path: [(pattern_name, snippet, line), ...]}."""
    results = {}
    for dirpath, _, filenames in os.walk(root):
        if "venv" in dirpath or ".git" in dirpath or "__pycache__" in dirpath or "node_modules" in dirpath:
            continue
        for name in filenames:
            if not name.endswith(extensions):
                continue
            path = os.path.join(dirpath, name)
            rel = os.path.relpath(path, root)
            findings = scan_file(path)
            if findings:
                results[rel] = findings
    return results


def run_malware_scan(paths: List[str] = None, root: str = None) -> Dict:
    """Esegue scan su lista file o su root. Restituisce report."""
    import os
    from datetime import datetime
    root = root or os.getcwd()
    if paths:
        results = {}
        for p in paths:
            if os.path.isfile(p):
                rel = os.path.relpath(p, root) if os.path.abspath(p).startswith(os.path.abspath(root)) else p
                findings = scan_file(p)
                if findings:
                    results[rel] = [{"pattern": n, "snippet": s, "line": ln} for n, s, ln in findings]
    else:
        raw = scan_directory(root)
        results = {k: [{"pattern": n, "snippet": s, "line": ln} for n, s, ln in v] for k, v in raw.items()}
    return {
        "phase": "malware_pattern_scan",
        "timestamp": datetime.utcnow().isoformat() + "Z",
        "root": root,
        "files_scanned": len(paths) if paths else len(list(scan_directory(root))),
        "files_with_findings": len(results),
        "findings": results,
    }
